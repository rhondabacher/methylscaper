#' Process single-cell data
#'
#' This function generates representation methylation-state matrices from 
#'  single-cell methylation data (for example, as generated by the Bismarck 
#'  software program). See the vignette for a more thorough explanation 
#'  of each parameter.
#'
#' @param gc_seq_data GC accessibility data, in the form of a list of 
#'  dataframes.
#' @param cg_seq_data CG methylation data, in the form of a list of 
#'  dataframes.
#' @param startPos The index of the first position to include 
#'  in the visualization. If using this within the R console it is 
#'  recomended to specify the start and end directly.
#'  In the Shiny app, a slider will let the user refine these positions.
#' @param endPos The index of the final position to include in the visualization.
#' @param updateProgress A function for generating progress bars in the Shiny app. 
#'   Should be left NULL otherwise.
#' @return The output is a list containing the elements 'gch' and 'hcg. 
#'      Each is a dataframe with reads/cells on the rows and each column 
#'      is a base-pair. The matrix is coded as follows:
#'          -2: unmethylated GCH or HCG site
#'          -1: base pairs between two unmethylated GCH or HCG sites
#'          0: base pairs between mismatching methylation states of 
#'              two GCH or HCG sites
#'          1: base pairs between two methylated GCH or HCG sites
#'          2: methylated GCH or HCG site
#' @importFrom utils tail
#' @export
#' @examples 
#'  
#' data(chr19_example_HCG)
#' data(chr19_example_GCH)
#' prepsc.out <- prepSC(chr19_example_GCH, chr19_example_HCG, 
#'                  startPos = 105636488, endPos = 105636993)

prepSC <- function(gc_seq_data, cg_seq_data, startPos=NULL, endPos=NULL,
                     updateProgress = NULL)
{
    if (is.function(updateProgress))
            updateProgress(message = "Filtering CG data", value = 0.1)
    
    if (is.null(startPos) & is.null(endPos)) {
        cg.max.pos <- max(vapply(cg_seq_data, FUN=function(x) {max(x$pos)}, numeric(1)))
        cg.min.pos <- min(vapply(cg_seq_data, FUN=function(x) {min(x$pos)}, numeric(1)))
        gc.max.pos <- max(vapply(gc_seq_data, FUN=function(x) {max(x$pos)}, numeric(1)))
        gc.min.pos <- min(vapply(gc_seq_data, FUN=function(x) {min(x$pos)}, numeric(1)))
        
        startPos <- pmax(cg.min.pos, gc.min.pos)
        endPos <- startPos + 1000
     }
     cg_seq_sub <- lapply(cg_seq_data, function(x) {
         QQ <- x[order(x$pos),]
         QQ = subset(QQ, QQ$pos >= startPos & QQ$pos <= endPos)
    return(QQ)
     })

    if (is.function(updateProgress))
         updateProgress(message = "Filtering GC data", value = 0.5)
     gc_seq_sub <- lapply(gc_seq_data, function(x) {
         QQ <- x[order(x$pos),]
         QQ = subset(QQ, QQ$pos >= startPos & QQ$pos <= endPos)
         return(QQ)
      })
    all_cg_sites <- unique(do.call(c, cg_seq_sub))
    all_gc_sites <- unique(do.call(c, gc_seq_sub))
    useseq <- intersect(which(vapply(cg_seq_sub, function(x) nrow(x), numeric(1)) > 1 ),
                      which(vapply(gc_seq_sub, function(x) nrow(x), numeric(1)) > 1 ))
    if (length(useseq) == 0) return()

    cg_seq_sub <- cg_seq_sub[useseq]
    gc_seq_sub <- gc_seq_sub[useseq]

    if (is.function(updateProgress))
        updateProgress(message = "Mapping CG data", value = 0.75)
    cg_outseq <- lapply(cg_seq_sub, function(x) mapSC(x, startPos, endPos))
    hcg <- data.matrix(do.call(rbind, cg_outseq))
    rownames(hcg) <- as.character(seq(1,nrow(hcg)))

    if (is.function(updateProgress))
        updateProgress(message = "Mapping GC data", value = 0.9)
    gc_outseq <- lapply(gc_seq_sub, function(x) mapSC(x, startPos, endPos))
    gch <- data.matrix(do.call(rbind, gc_outseq))
    rownames(gch) <- as.character(seq(1,nrow(gch)))

    return(list(gch = gch, hcg = hcg))

}

mapSC <- function(IN.seq, startPos, endPos) {
    IN.seq$pos <- IN.seq$pos - startPos + 1
    fill.1 <- seq(startPos, endPos) - startPos + 1
    someMethyl <- which(IN.seq$rate > 0)
    noMethyl <- which(IN.seq$rate <= 0)
    fill.1[fill.1 %in% IN.seq[someMethyl,]$pos] <- 2
    fill.1[fill.1 %in% IN.seq[noMethyl,]$pos] <- -2
    fill.1[abs(fill.1) != 2] <- "."
    tail(sort(table(fill.1)))

    sites = IN.seq$pos
    editseq = fill.1
    sites.temp <- c(0, sites, max(sites)+1)

    for (j in seq(1,(length(sites.temp)-1))) {
    tofill <- seq(sites.temp[j]+1,(sites.temp[j+1]-1))
    s1 <- editseq[pmax(1, sites.temp[j])]
    s2 <- editseq[pmin(length(editseq), sites.temp[j+1])]

    if (s1 == "2" & s2 == "2") {
        fillvec <- 1 } else if (s1 == "2" & s2 == "-2") {
        fillvec <- 0} else if (s1 == "-2" & s2 == "2") {
        fillvec <- 0} else if (s1 == "-2" & s2 == "-2") {
        fillvec <- -1} else {fillvec <- 0}
        fillvec <- rep(fillvec, length(tofill))
        editseq[tofill] <- fillvec
    }
    return(editseq)
}
