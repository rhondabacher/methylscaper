#' Process single-cell data
#'
#' This function generates representation methylation-state matrices from single-cell methylation data (for example, as generated by the Bismarck software program). See the vignette for a more thorough explanation of each parameter.
#'
#' @param gc_seq_data GC accessibility data, in the form of a list of dataframes.
#' @param cg_seq_data CG methylation data, in the form of a list of dataframes.
#' @param startPos The index of the first position to include in the visualization.
#' @param endPos The index of the final position to include in the visualization.
#' @param updateProgress A function for generating progress bars in the Shiny app. Should be left NULL otherwise.
#' @importFrom utils tail
#' @export
prepSC <- function(gc_seq_data, cg_seq_data, startPos, endPos,
                   updateProgress = NULL)
{
    if (is.function(updateProgress))
        updateProgress(message = "Filtering CG data", value = 0.1)
  cg_seq_sub <- lapply(cg_seq_data, function(x) {
    QQ <- x[order(x$pos),]
    QQ = subset(QQ, pos >= startPos & pos <= endPos)
    return(QQ)
  })

    if (is.function(updateProgress))
        updateProgress(message = "Filtering GC data", value = 0.5)
  gc_seq_sub <- lapply(gc_seq_data, function(x) {
    QQ <- x[order(x$pos),]
    QQ = subset(QQ, pos >= startPos & pos <= endPos)
    return(QQ)
  })

  all_cg_sites <- unique(do.call(c, cg_seq_sub))
  all_gc_sites <- unique(do.call(c, gc_seq_sub))

  useseq <- intersect(which(sapply(cg_seq_sub, function(x) nrow(x)) > 1 ),
                      which(sapply(gc_seq_sub, function(x) nrow(x)) > 1 ))
  if (length(useseq) == 0)
  {
    return()
  }

  cg_seq_sub <- cg_seq_sub[useseq]
  gc_seq_sub <- gc_seq_sub[useseq]


    if (is.function(updateProgress))
        updateProgress(message = "Mapping CG data", value = 0.75)
  cg_outseq <- lapply(cg_seq_sub, function(x) mapSC(x, startPos, endPos))
  hcg <- data.matrix(do.call(rbind, cg_outseq))
  rownames(hcg) <- as.character(1:nrow(hcg))

    if (is.function(updateProgress))
        updateProgress(message = "Mapping GC data", value = 0.9)
  gc_outseq <- lapply(gc_seq_sub, function(x) mapSC(x, startPos, endPos))
  gch <- data.matrix(do.call(rbind, gc_outseq))
  rownames(gch) <- as.character(1:nrow(gch))

  return(list(gch = gch, hcg = hcg))

}

mapSC <- function(IN.seq, startPos, endPos) {
  IN.seq$pos <- IN.seq$pos - startPos + 1
  fill.1 <- seq(startPos, endPos) - startPos + 1
  someMethyl <- which(IN.seq$rate > 0)
  noMethyl <- which(IN.seq$rate <= 0)
  fill.1[fill.1 %in% IN.seq[someMethyl,]$pos] <- 2
  fill.1[fill.1 %in% IN.seq[noMethyl,]$pos] <- -2
  fill.1[abs(fill.1) != 2] <- "."
  tail(sort(table(fill.1)))

  sites = IN.seq$pos
  editseq = fill.1
  sites.temp <- c(0, sites, max(sites)+1)

  for (j in 1:(length(sites.temp)-1)) {
    tofill <- seq(sites.temp[j]+1,(sites.temp[j+1]-1))
    s1 <- editseq[pmax(1, sites.temp[j])]
    s2 <- editseq[pmin(length(editseq), sites.temp[j+1])]

    if (s1 == "2" & s2 == "2") {
      fillvec <- 1 } else if (s1 == "2" & s2 == "-2") {
        fillvec <- 0} else if (s1 == "-2" & s2 == "2") {
          fillvec <- 0} else if (s1 == "-2" & s2 == "-2") {
            fillvec <- -1} else {fillvec <- 0}
    fillvec <- rep(fillvec, length(tofill))
    editseq[tofill] <- fillvec
  }
  return(editseq)
}

## this is the first function called
## it takes a path to the datafiles and a chromosome number as arguments and returns the desired subset of the data
## this code is taken straight from the vignette
#' @export
subsetSC <- function(path, chromosome, startPos = NULL, endPos = NULL)
{
  # browser()
  cur.dir <- getwd()
  setwd(path) ### this is probably bad practice, but it seems like the easiest solution for now
  cgfiles <- sort(grep("met", list.files(path), value = T))
  gcfiles <- sort(grep("acc", list.files(path), value = T))

  useChr <- chromosome

  cg.seq <- list()
  for(i in 1:length(cgfiles)) {
    cg.seq[[i]] <- fread(cgfiles[i], header=F, stringsAsFactors = F)
    colnames(cg.seq[[i]]) <- c("chr", "pos", "rate")
    cg.seq[[i]] <- cg.seq[[i]][order(cg.seq[[i]]$pos), ]

    cg.seq[[i]] <- subset(cg.seq[[i]], chr==useChr)
    if (!is.null(startPos) & !is.null(endPos))
     {
      cg.seq[[i]] <- subset(cg.seq[[i]], pos >= startPos & pos <= endPos)
    }
  }

  gc.seq<- list()
  for(i in 1:length(gcfiles)) { ## this is where it breaks
    gc.seq[[i]] <- fread(gcfiles[i], header=F, stringsAsFactors = F,
                              colClasses = c("character", "numeric", "numeric"))
    colnames(gc.seq[[i]]) <- c("chr", "pos", "rate")
    gc.seq[[i]] <- gc.seq[[i]][order(gc.seq[[i]]$pos), ]
    gc.seq[[i]] <- subset(gc.seq[[i]], chr==useChr)
    if (!is.null(startPos) & !is.null(endPos))
     {
      gc.seq[[i]] <- subset(gc.seq[[i]], pos >= startPos & pos <= endPos)
    }
  }

  setwd(cur.dir)

  list(cg.seq.sub = cg.seq, gc.seq.sub = gc.seq)
}
