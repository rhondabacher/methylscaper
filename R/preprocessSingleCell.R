#' Process single-cell data
#'
#' This function generates representation methylation-state matrices from 
#'  single-cell methylation data (for example, as generated by the Bismarck 
#'  software program). See the vignette for a more thorough explanation 
#'  of each parameter.
#'
#' @param gc_seq_data GC accessibility data, in the form of a list of 
#'  dataframes.
#' @param cg_seq_data CG methylation data, in the form of a list of 
#'  dataframes.
#' @param startPos The index of the first position to include 
#'  in the visualization. If using this within the R console it is 
#'  recomended to specify the start and end directly.
#'  In the Shiny app, a slider will let the user refine these positions.
#' @param endPos The index of the final position to include in the visualization.
#' @param updateProgress A function for generating progress bars in the Shiny app. 
#'   Should be left NULL otherwise.
#' @return The output is a list containing the elements 'gch' and 'hcg. 
#'      Each is a dataframe with reads/cells on the rows and each column 
#'      is a base-pair. The matrix is coded as follows:
#'          -2: unmethylated GCH or HCG site
#'          -1: base pairs between two unmethylated GCH or HCG sites
#'          0: base pairs between mismatching methylation states of 
#'              two GCH or HCG sites
#'          1: base pairs between two methylated GCH or HCG sites
#'          2: methylated GCH or HCG site
#' @importFrom utils tail
#' @export
#' @examples 
#'  
#' data(chr19_example_HCG)
#' data(chr19_example_GCH)
#' prepsc.out <- prepSC(chr19_example_GCH, chr19_example_HCG, 
#'                  startPos = 105636488, endPos = 105636993)

prepSC <- function(gc_seq_data, cg_seq_data, startPos=NULL, endPos=NULL,
                     updateProgress = NULL)
{

    if (is.function(updateProgress)) 
        updateProgress(message = "Filtering CG data", value = 0.1)
    
    if (is.null(startPos) & is.null(endPos)) {
        cg.max.pos <- max(vapply(cg_seq_data, FUN=function(x) {max(x$pos)}, numeric(1)))
        cg.min.pos <- min(vapply(cg_seq_data, FUN=function(x) {min(x$pos)}, numeric(1)))
        gc.max.pos <- max(vapply(gc_seq_data, FUN=function(x) {max(x$pos)}, numeric(1)))
        gc.min.pos <- min(vapply(gc_seq_data, FUN=function(x) {min(x$pos)}, numeric(1)))
        
        startPos <- pmax(cg.min.pos, gc.min.pos)
        endPos <- startPos + 3000
    }
    cg_seq_sub <- lapply(cg_seq_data, function(x) {
        QQ <- x[order(x$pos),]
        QQ = subset(QQ, QQ$pos >= startPos & QQ$pos <= endPos)
    return(QQ)
    })

    if (is.function(updateProgress))
         updateProgress(message = "Filtering GC data", value = 0.5)
    
    gc_seq_sub <- lapply(gc_seq_data, function(x) {
         QQ <- x[order(x$pos),]
         QQ = subset(QQ, QQ$pos >= startPos & QQ$pos <= endPos)
         return(QQ)
    })
    
    all_cg_sites <- unique(do.call(c, cg_seq_sub))
    all_gc_sites <- unique(do.call(c, gc_seq_sub))
    useseq <- intersect(which(vapply(cg_seq_sub, function(x) nrow(x), numeric(1)) > 1 ),
                which(vapply(gc_seq_sub, function(x) nrow(x), numeric(1)) > 1 ))
    
    if (length(useseq) == 0) return()

    cg_seq_sub <- cg_seq_sub[useseq]
    gc_seq_sub <- gc_seq_sub[useseq]

    if (is.function(updateProgress))
        updateProgress(message = "Mapping CG data", value = 0.75)
    
    cg_outseq <- lapply(cg_seq_sub, function(x) {
        if (nrow(x) == 0) NULL
            else mapSC(x, startPos, endPos)
    })
    
    cg_outseq <- cg_outseq[!vapply(cg_outseq, is.null, logical(1))]
    hcg <- data.matrix(do.call(rbind, cg_outseq))
    rownames(hcg) <- as.character(seq(1,nrow(hcg)))

    if (is.function(updateProgress))
        updateProgress(message = "Mapping GC data", value = 0.9)
    
    gc_outseq <- lapply(gc_seq_sub, function(x) {
        if (nrow(x) == 0) NULL
        else mapSC(x, startPos, endPos)
    })
    
    gc_outseq <- gc_outseq[!vapply(gc_outseq, is.null, logical(1))]
    gch <- data.matrix(do.call(rbind, gc_outseq))
    rownames(gch) <- as.character(seq(1,nrow(gch)))

    return(list(gch = gch, hcg = hcg))

}

mapSC <- function(IN.seq, startPos, endPos) {

    IN.seq$pos <- as.numeric(IN.seq$pos) - startPos + 1
    fill.1 <- seq(startPos, endPos) - startPos + 1
    someMethyl <- which(IN.seq$rate > 0)
    noMethyl <- which(IN.seq$rate <= 0)
    fill.1[fill.1 %in% IN.seq[someMethyl,]$pos] <- 2
    fill.1[fill.1 %in% IN.seq[noMethyl,]$pos] <- -2
    fill.1[abs(fill.1) != 2] <- "."
    tail(sort(table(fill.1)))

    sites = as.numeric(IN.seq$pos)
    sites <- sites[sites > 0]
    editseq = fill.1
    sites.temp <- c(0, sites, max(sites)+1)

    for (j in seq(1,(length(sites.temp)-1))) {
        if (sites.temp[j+1] == 1) { # skip 
        } else {
            tofill <- seq(sites.temp[j]+1,(sites.temp[j+1]-1))
            s1 <- editseq[pmax(1, sites.temp[j])]
            s2 <- editseq[pmin(length(editseq), sites.temp[j+1])]

            if (s1 == "2" & s2 == "2") {
                fillvec <- 1 } else if (s1 == "2" & s2 == "-2") {
                fillvec <- 0} else if (s1 == "-2" & s2 == "2") {
                fillvec <- 0} else if (s1 == "-2" & s2 == "-2") {
                fillvec <- -1} else {fillvec <- 0}
                fillvec <- rep(fillvec, length(tofill))
                editseq[tofill] <- fillvec
            }
    }
    return(editseq)
}



#' Load in and subset methylation data
#'
#' This function loads the single-cell files. It takes a path to the datafiles
#' and a chromosome number as arguments and returns the desired subset of the 
#' data. The files should be tab separated with three columns.
#' The first column is the chromosome, the second is the position (basepair), and the third
#' is the methylation indicator/rate. The folder should contain two subfolders titled
#' met and acc, with the endogenous methylation and accessibility methylation files,
#' respectively.
#'
#' @param path Path to the folder containing the single-cell files.
#' @param chromosome The chromosome to subset the files to.
#' @param startPos The index of the first position to include 
#'  in the subsetting. This is optional as further narrowing of the 
#'  position can be doen in the visualization step/tab.
#'  In the Shiny app, a slider will let the user refine the positions.
#' @param endPos The index of the final position to include in subset.
#' @param updateProgress A function for generating progress bars in the Shiny app. 
#'   Should be left NULL otherwise.
#' @return The output is RDS files that can be loaded into the visualization 
#'  tab on the Shiny app
#' @importFrom data.table fread
#' @export
#'
#' @examples 
#' # example not run since needs directory input from user
#' #subsc.out <- subsetSC("filepath", chromosome=19)

subsetSC <- function(path, chromosome, startPos = NULL, endPos = NULL, updateProgress = NULL)
{
    cur.dir <- getwd()

    cgfiles <- sort(grep("met", list.files(paste0(path,"/met")), value = TRUE))
    gcfiles <- sort(grep("acc", list.files(paste0(path,"/acc")), value = TRUE))

    useChr <- chromosome

    cg.seq <- list()
    for(i in seq(1,length(cgfiles))) {
        in_cg_seq <- fread(paste0(path,"/","met/",cgfiles[i]), header=FALSE, stringsAsFactors = FALSE)
        if (in_cg_seq[1,1] == "chr") {
            in_cg_seq <- in_cg_seq[-1,]
        }
        colnames(in_cg_seq) <- c("chr", "pos", "rate")
        in_cg_seq$pos <- as.numeric(in_cg_seq$pos)
        in_cg_seq$rate <- as.numeric(in_cg_seq$rate)
        in_cg_seq <- in_cg_seq[order(in_cg_seq$pos), ]

        in_cg_seq <- subset(in_cg_seq, in_cg_seq$chr==useChr)
        if (!is.null(startPos) & !is.null(endPos)) {
            in_cg_seq <- subset(in_cg_seq, in_cg_seq$pos >= startPos & in_cg_seq$pos <= endPos)
        }
        
        cg.seq[[i]] <- in_cg_seq
        if (is.function(updateProgress))
            updateProgress(message = "Reading CG files", value = i / length(cgfiles))
    }

    gc.seq<- list()
    for(i in seq(1,length(gcfiles))) { 
        in_gc_seq <- fread(paste0(path,"/","acc/",gcfiles[i]), header=FALSE, stringsAsFactors = FALSE)
        colnames(in_gc_seq) <- c("chr", "pos", "rate")
        if (in_gc_seq[1,1] == "chr") {
            in_gc_seq <- in_gc_seq[-1,]
        }
        colnames(in_gc_seq) <- c("chr", "pos", "rate")
        in_gc_seq$pos <- as.numeric(in_gc_seq$pos)
        in_gc_seq$rate <- as.numeric(in_gc_seq$rate)
        in_gc_seq <- in_gc_seq[order(in_gc_seq$pos), ]
        in_gc_seq <- subset(in_gc_seq, in_gc_seq$chr==useChr)

        if (!is.null(startPos) & !is.null(endPos)) {
            in_gc_seq <- subset(in_gc_seq, in_gc_seq$pos >= startPos & in_gc_seq$pos <= endPos)
         }
         
        gc.seq[[i]] <- in_gc_seq
        if (is.function(updateProgress))
            updateProgress(message = "Reading GC files", value = i / length(gcfiles))
    }

    setwd(cur.dir)

    list(cg.seq.sub = cg.seq, gc.seq.sub = gc.seq)
}
